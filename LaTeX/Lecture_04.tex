\part*{Lecture 4: \\Classes}

Last time we learned functions --- which enable you to expand your language to express more complex \emph{processes}.
Today we'll learn another tool, classes, which will help to manage complexity in your programs --- by expanding your language to express more complex \emph{data}.

First, a little vocabulary. In Python, every variable or expression belongs to a type --- such as a boolean, integer, or float. A particular example of a type, say the integer \texttt{7}, is said to be an instance of the class \texttt{Int}. Similarly, the expression \texttt{True} is an instance of the class \texttt{Bool}.

Now suppose you were interested in writing a program to model the basic genetics of breeding pea plants. 

\section*{Genetics Background}
We'll be considering two traits: flower color and stem length. Each plant has two versions (alleles) of the gene for each of these traits. 
The possible alleles for flower color are `white' and `purple' and the possible alleles for stem length are `long' and `short'.
The genotype of a plant is the allele pairs it carries (one possible genotype is (`white', `white') for flower color and (`long', `short') for stem length, for example).
The genotype in turn determines the phenotype of the plant --- what it actually looks like. For flower color, `purple' is dominant, so if the plant has even one `purple' allele it will be purple.
Similarly, if a plant has even one `long' allele, it will have a long stem. When two plants breed, each passes on one of its alleles to its offspring.

\section*{Back to Python}
Wouldn't it be nice if you had a new type, not \texttt{Int} or \texttt{Bool}, but PeaPlant? And the PeaPlant type supported operations such as \texttt{get\_genotype}, \texttt{get\_phenotype}, and a breed operator which would take two
instances of PeaPlant and give a new instance which was a genetic combination?

All of this can be done in a straightforward way by defining a new Python class, and endowing it with \emph{attributes} (private data each instance will have, such as the plant's genotype), and \emph{methods} (special functions like \texttt{get\_genotype} or \texttt{breed}, which only apply to the PeaPlant class). With the PeaPlant class defined, we can easily write clear and elegant programs to model pea plants.

The complete code to define the \texttt{PeaPlant} class follows. Don't be overwhelmed --- it will make sense when you read the explanation after.

\clearpage

\begin{lstlisting}
import random

class PeaPlant():
	def __init__(self, flower_allele_1, flower_allele_2, stem_allele_1, 
	             stem_allele_2):
		self.flower_genotype = (flower_allele_1, flower_allele_2)
		self.stem_genotype = (stem_allele_1, stem_allele_2)
	def get_genotype(self):
		return (self.flower_genotype, self.stem_genotype)
	def get_phenotype(self):
		if self.flower_genotype == ('white', 'white'):
			flower_phenotype = 'white'
		else:
			flower_phenotype = 'purple'
		if self.stem_genotype == ('short', 'short'):
			stem_phenotype = 'short'
		else:
			stem_phenotype = 'long'
		return (flower_phenotype, stem_phenotype)
	def __add__(self, other_plant): # Breeding operation
		# Randomly chooses an element of the flower_genotype attribute
		flower_allele_1 = random.choice(self.flower_genotype) 
		flower_allele_2 = random.choice(other_plant.flower_genotype)
		stem_allele_1 = random.choice(self.stem_genotype)
		stem_allele_2 = random.choice(other_plant.stem_genotype)
		return PeaPlant(flower_allele_1, flower_allele_2, stem_allele_1, 
		                stem_allele_2)
	
def build_random_pea_plant():
	flower_alleles = ['white', 'purple']
	stem_alleles = ['short', 'long']
	return PeaPlant(random.choice(flower_alleles), 
	                random.choice(flower_alleles), 
	                random.choice(stem_alleles), 
	                random.choice(stem_alleles))
\end{lstlisting}

OK, so what's all this doing? We begin by importing the \texttt{random} library, so we can use its functions to build randomization into the breeding process.
Next we define the \texttt{PeaPlant} \texttt{\textbf{class}}. The \texttt{\textbf{class}} definition begins with the class declaration \texttt{\textbf{class} PeaPlant()}, which lets python know that the following indented code will define a new \texttt{\textbf{class}}, with the name \texttt{PeaPlant}.

Next, we define the \texttt{\_\_init\_\_} method (remember method is the term for a \emph{private} function for a class). This method must be defined any time you define a new \texttt{\textbf{class}}, and it describes how a new instance of a \texttt{\textbf{class}} is built. In the case of \texttt{PeaPlant}, you must create an instance of \texttt{PeaPlant} by providing the plant's genetic information as described by the parameters.

For example, you could create a plant like this:

\begin{lstlisting}[numbers=none]
>>> sample_plant = PeaPlant('white', 'purple', 'long', 'long')
\end{lstlisting}
 
It's just a fact of the Python language that the first parameter of any method must be self, but you pretend that variable spot doesn't exist when you call the function.

The \texttt{\_\_init\_\_} definition then specifies that the genetic data is stored in two attributes \emph{(private variables)}, \texttt{self.flower\_genotype} and \texttt{self.stem\_genotype}, which bundle the information in tuples. That's all for initialization.

The remaining methods describe operations that can be done on instances of the \texttt{PeaPlant} class. The first is \texttt{get\_genotype()}. Here's how it would be called on \texttt{sample\_plant}:

\begin{lstlisting}[numbers=none]
>>> sample_plant.get_genotype()
(('white', 'purple'), ('long', 'long'))
\end{lstlisting}

Notice that there's a new syntax for calling methods of a class, with the instance followed by a `\texttt{.}' and then the method. The intention is to reinforce the idea that methods are private to the class and this format must be used.

The \texttt{get\_phenotype} method works similarly:

\begin{lstlisting}[numbers=none]
>>> sample_plant.get_phenotype()
('purple', 'long')
\end{lstlisting}

The final method defined, \texttt{\_\_add\_\_}, is used to define the breeding process. It takes one other plant as a parameter, and returns a newly constructed plant as a genetic mixture of the two plants. Note that this process is where we use the \texttt{random} library via the \texttt{random.choice} function. \texttt{random.choice()} takes in a list or tuple and returns a random item from it. Here's an example use.

\begin{lstlisting}[numbers=none]
>>> plant_2 = PeaPlant('purple', 'white', 'short', 'short')
>>> child_plant = sample_plant.__add__(plant_2)
\end{lstlisting}

How come I gave it an obscure name like \texttt{\_\_add\_\_} instead of something more descriptive --- like `breed'? The reason is that I'm defining how the built in Python addition function, '\texttt{+}', will interact with the \texttt{PeaPlant} \texttt{\textbf{class}}. \texttt{\_\_add\_\_} is the reserved method name which allows you to do this. So we can use the \texttt{\_\_add\_\_} method more conveniently like this:

\begin{lstlisting}[numbers=none]
>>> second_child = sample_plant + plant_2
\end{lstlisting}

There are a variety of special method names like `\texttt{\_\_add\_\_}' which enable your classes to interact with built in python functions. These methods, termed `magic methods' in the Python documentation, also include `\texttt{\_\_cmp\_\_}' (so you can compare instances with \texttt{==}), `\texttt{\_\_len\_\_}' (so you can take the `length' of an instance), and many others. These magic methods are only occasionally used in practice, however.