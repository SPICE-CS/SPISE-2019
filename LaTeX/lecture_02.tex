% Lecture 2
% Daniel Ellison 2019
% LaTeX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part*{Lecture 2: \\ Handling More Complex Data}

Last time you got a feel for many of python's basic features: doing arithmetic with integers and floating point numbers, assigning values to variables for later use, working with strings (text), and doing a bit of logic with Boolean True/False expressions.

So far, though, we've only covered how to store one number or chunk of text at a time. Imagine you wanted to write a program to analyze the weather in Barbados. If you had hourly temperature measurements over a range of even a few weeks, this would amount to hundreds of numbers! Or imagine you're writing a program to generate short English poems and want your program to have access to an English dictionary consisting of tens of thousands of words. Both these problems would require working with many stored numbers or strings--and it's definitely not feasible to assign each to its own variable. Let's get acquainted with some new Python types which are designed to handle such complexity.


\section*{Lists}

First we'll look at the list type, which allows you to form a sequence of python objects (a python object is anything with a type, such as an integer or string). Take the following example:

\begin{lstlisting}[numbers=none]
>>> small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
\end{lstlisting}

The above statement assigns the list with elements \texttt{2}, \texttt{3}, ..., \texttt{29} to the variable \texttt{small\_primes}. The items in a list are called its \emph{elements}, and you can access the elements in a list by their \emph{index} (position in the list, remember counting starts at 0!). For example, if we wanted to print the \texttt{7} (at index 3), we could perform the following command:

\begin{lstlisting}[numbers=none]
>>> print(small_primes[3])
7
\end{lstlisting}

You might recognize the slicing notation as the same syntax used to pick out a certain character in a string. This is because the writer of Python chose similar syntax to make the language easy to remember.  You can also pick out larger segments of a list. For example, the following command constructs a list of the items at index 2 up to (but not including) index 5, and assigns it to a new variable.

\begin{lstlisting}[numbers=none]
>>> a_few_small_primes = small_primes[2:5]
>>> print(a_few_small_primes)
[5, 7, 11]
\end{lstlisting}

It's also frequently useful to add an element to the end of a list, which you can do with the \texttt{append} command.

\begin{lstlisting}[numbers=none]
>>> common_english_names = ['Mary', 'John', 'Emily', 'Ethan']
>>> common_english_names.append('Susan')
>>> print(common_english_names)
['Mary', 'John', 'Emily', 'Ethan', 'Susan']
\end{lstlisting}

The two examples of lists so far have contained elements of all the same type (ints in \texttt{small\_primes}, and strings in \texttt{common\_english\_names}), but there are no rules for what types of objects a list can contain:

\begin{lstlisting}[numbers=none]
>>> funky_list = ['cat', 17, ['rutabaga', 'cabbage']]
\end{lstlisting}

The above list is certainly unusual, containing a string, integer, and even another list---but it's perfectly legal to construct a list like this. 

You can even create a list without any elements!

\begin{lstlisting}[numbers=none]
>>> empty_list = []
\end{lstlisting}

Does this list really have nothing in it? We can check with the \texttt{\textbf{len}} command--which works on all lists, not just empty ones, to give the number of elements.

\begin{lstlisting}[numbers=none]
>>> len(empty_list)
0
\end{lstlisting}

Why would we want to make an empty list? It's actually quite common. The typical reason is that you want your program to build the list for you using append --- either because you don't yet know what should be in it, or it would be too tedious to type in all the elements by hand. You'll see an example of this later today.


\section*{For Loops}

Let's move on to \texttt{for} loops by way of an example. Suppose we'd like to find the average of the numbers in \texttt{small\_primes}. One way would be to add them all up and then divide by the number of numbers in the list. Let's put this idea in code.

\begin{lstlisting}
small_primes = [2 ,3, 5, 7, 11, 13, 17, 19, 23, 29]
running_total = 0
for number in small_primes:
	running_total = running_total + number
average = running_total / len(small_primes)
print(average)
\end{lstlisting}

Running this program will then print the average value, \texttt{12.9}. So what's happening in the \texttt{for} loop? It's running through the \texttt{small\_primes} list, in order, each time running the code in the loop (in this case just one line), with the variable \texttt{number} set to the current element in the list.

We can also use a for loop to build a new list based on an old one. Suppose we wanted to filter out small primes ending in 3:

\begin{lstlisting}
small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
primes_ending_in_3 = []
for number in small_primes:
	if number % 10 == 3:
		primes_ending_in_3.append(number)
print(primes_ending_in_3)
\end{lstlisting}

For loops aren't limited to just stepping through lists. In fact, any python object which can be stepped through one at a time can be used in place of a list in a for loop. For example, a string can be stepped through one character at a time. The following code prints the letters of \texttt{\textquotesingle hippopatamus\textquotesingle} one at a time.

\begin{lstlisting}
for letter in 'hippopotamus':
	print(letter)
\end{lstlisting}

Another use of \texttt{for} loops is to repeat the code inside a fixed number of times. This is accomplished as shown, using the \texttt{\textbf{range}} command:

\begin{lstlisting}
for i in range(10):
	print('Running the for loop: ' + time + str(i))
\end{lstlisting}

The above code will run 10 times, with \texttt{i} set to \texttt{0}, \texttt{1}, ..., \texttt{9}. 


\section*{While Loops}

While we're on the subject of loops, let's take a look at the other type of loop in python--the \texttt{while} loop. The \texttt{while} loop keeps on running the code inside while a given Boolean expression is \texttt{True}.

Take the following piece of code, which repeats a certain arithmetic procedure until \texttt{current\_number} becomes \texttt{1}, after which the program ends.

\begin{lstlisting}
current_number = 10
while current_number != 1: 
	# != means not equal to (you can add notes like these by using a # at the 
	# end of a line and then typing the note after)
	print(current_number)
	if current_number % 2 == 0:
		current_number = current_number / 2
	else:
		current_number = current_number * 3 + 1
\end{lstlisting}

If the Boolean expression is always \texttt{True}, the while loop will keep repeating forever--an infinite loop! If your program doesn't seem to be stopping, while loops are a good thing to check.


\section*{Reading and Writing Text Files}

Often times, when writing a program, you'll be working with data from an external source (such as temperature data from a weather station, or a dictionary of words in the English language). This external data can come in a variety of formats, such as .txt or .csv, and will need to be read in to your program and stored. Later, once your program has completed its work, you might also want to create an output file to give to someone else. 
Python makes it easy to read and write .txt files --- let's get to it!

Suppose we'd like to load a dictionary into one of our programs and are given a .txt file like this (a section of the A's shown below):

\begin{verbatim}
...
abase
abased
abasedly
abasedness
abasement
abasements
abaser
...
\end{verbatim}

First, we'll need to open the .txt file as a file object, which can be done by the \texttt{\textbf{open}} command.

\begin{lstlisting}[numbers=none]
>>> dictionary_file = open('words.txt' , 'r') 
>>> # words.txt is the filename and the 'r' means open the file to read.
\end{lstlisting}

Next, we can use the read command to scan the file, turning it's contents into a really big string:

\begin{lstlisting}[numbers=none]
>>> dictionary_raw_text = dictionary_file.read()
\end{lstlisting}

Now that we've assigned the raw text to the variable \texttt{dictionary\_raw\_text}, we should close the file to save memory:

\begin{lstlisting}[numbers=none]
>>> dictionary_file.close()
\end{lstlisting}

The string stored to \texttt{dictonary\_raw\_text} takes the form of many words separated by line breaks (remember line breaks are just the \texttt{\textbackslash n} newline character). We can put all the items between the line breaks (the words) into a big list using the \texttt{split} command.

\begin{lstlisting}[numbers=none]
>>> dictionary_word_list = dictionary_raw_text.split()
\end{lstlisting}

Now the words of the dictionary have been successfully been brought into the program --- stored in a handy list. That's about all there is to reading in a text file. To learn how to write a text file, let's create a .txt file of all the words which are 12 letters long.

First we'll create an output file:

\begin{lstlisting}[numbers=none]
>>> long_words = open('twelve_letter_words.txt', 'w') 
>>> # twelve_letter_words.txt is the name for the new file, 
>>> # 'w' since we'll be writing the file
\end{lstlisting}

Next we'll create an empty string which we'll build up with the twelve-letter words we find (and eventually write to the file):

\begin{lstlisting}[numbers=none]
to_write = ''
\end{lstlisting}

Now we'll run through the words in the dictionary to form the \texttt{to\_write} string:

\begin{lstlisting}[numbers=none]
>>> for word in dictionary_word_list:
...	    if len(word) == 12:
...	        to_write = to_write + word + '\n' 
...	        # the '\n' is so we have line breaks between the words
\end{lstlisting}

Now we write the \texttt{to\_write} string to the output file and close it up:

\begin{lstlisting}[numbers=none]
>>> long_words.write(to_write)
>>> long_words.close()
\end{lstlisting}

That's all there is to it!


\section*{Tuples and Dictionaries}

We'll close the lecture portion of today's class with two more python types to handle more complex data. The first is the tuple type. Since you know lists, tuples are really easy. They're just lists which, after you create them, cannot change. Here's an example:

\begin{lstlisting}[numbers=none]
>>> my_name_and_age = ('Matt', 21). 
\end{lstlisting}

If I were to then try to modify the element at index 1 (the integer \texttt{21}) with the following:

\begin{lstlisting}[numbers=none]
>>> my_name_and_age[1] = 22 # happy birthday!
\end{lstlisting}

Python would give me an error since tuples cannot be modified. The formal way to say that tuples cannot be modified is that they are \emph{immutable}. Lists on the other hand are \emph{mutable} --- for example, the following works just fine: (incidentally, strings are also immutable)

\begin{lstlisting}[numbers=none]
>>> my_name_and_age_list = ['Matt', 21]
>>> my_name_and_age_list[1] = 22
>>> print(my_name_and_age_list)
['Matt', 22]
\end{lstlisting}

You can also turn a list into a \texttt{\textbf{tuple}} with the tuple command:

\begin{lstlisting}[numbers=none]
>>> my_name_and_age_tuple = tuple(my_name_and_age_list)
\end{lstlisting}

or vice versa with the \texttt{\textbf{list}} command:

\begin{lstlisting}[numbers=none]
>>> my_name_and_age_list_for_real = list(my_name_and_age)
\end{lstlisting}

Why would you want to use a tuple instead of a list? For one, they're a bit more memory efficient since they don't reserve space for possible append commands --- though this is rarely a concern for the programs you'll be writing. The main reason is that they can be used as ``keys in a dictionary". Of course this doesn't make any sense without knowing what a dictionary is... Let's talk about dictionaries.

A dictionary is a Python type which can be used to associate pairs of objects. For example, suppose that we're creating a game which has various animals at different points in the x-y plane. We could store the animal positions using a dictionary to associate the animal names with their positions:

\begin{lstlisting}[numbers=none]
>>> animal_location_dictionary = {'cat': (3 ,2), 'gerbil': (-2, 3), 
						          'aardvark': (0, 0)}
\end{lstlisting}

Generally, the dictionary syntax is \texttt{{<key1> : <value1>, <key1> : <value1>, ...}}. If you'd like to access the value associated with a key, you can use the slicing syntax as shown:

\begin{lstlisting}[numbers=none]
>>> animal_location_dictionary['gerbil']
(-2,3)
\end{lstlisting}

In a way, dictionaries are a more flexible version of lists. In lists, items are associated with the indices 0,1,..., but in dictionaries the 'indices' (keys) can be any Python object --- \emph{WITH THE RULE THAT THE KEYS MUST BE IMMUTABLE OBJECTS}, like integers, strings, floats, or tuples.

You can add a new key-value pair to a dictionary like this:

\begin{lstlisting}[numbers=none]
>>> animal_location_dictionary['zebra'] = (14, 20)
>>> print(animal_location_dictionary)
{'cat': (3, 2), 'gerbil': (-2, 3), 'aardvark': (0, 0),'zebra': (14, 20)}
\end{lstlisting}

Like with lists, you can also build an empty dictionary which you can add to later using the \texttt{\textbf{dict}} command:

\begin{lstlisting}[numbers=none]
>>> empty_dict = dict()
\end{lstlisting}

As a final note on dictionaries, they can also be looped through in for loops (the \texttt{for} loop will loop through the keys). Python doesn't provide any guarantee, however, for the order the keys will be looped through (dictionaries are so called \emph{unordered} types).

As an example, take the following code to make a list of all the positions of the animals:

\begin{lstlisting}
animal_positions = []
for animal in animal_location_dictionary:
	animal_positions.append(animal_location_dictionary[animal])
\end{lstlisting}
	
	